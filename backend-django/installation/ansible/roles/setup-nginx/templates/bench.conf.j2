# {{ app_name }} server configuration

# mapping for daphne and websockets
map $http_upgrade $connection_upgrade {
    default   upgrade;
    ''        close;
}

proxy_cache_path /nginx_proxy_cache levels=1:2 keys_zone=auth_cache:10m max_size=10g
                 inactive=1m use_temp_path=off;

# upstream (django)
upstream web {
    ip_hash;
    server unix:/run/daphne/socket fail_timeout=0;
}

# don't send the nginx version number in error pages and Server header
server_tokens off;

# This header enables the Cross-site scripting (XSS) filter built into most recent web browsers.
# It's usually enabled by default anyway, so the role of this header is to re-enable the filter for
# this particular website if it was disabled by the user.
# https://www.owasp.org/index.php/List_of_useful_HTTP_headers
add_header X-XSS-Protection "1; mode=block";

# config to don't allow the browser to render the page inside an frame or iframe
# and avoid clickjacking http://en.wikipedia.org/wiki/Clickjacking
# if you need to allow [i]frames, you can use SAMEORIGIN or even set an uri with ALLOW-FROM uri
# https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options
add_header X-Frame-Options SAMEORIGIN;

# with Content Security Policy (CSP) enabled(and a browser that supports it(http://caniuse.com/#feat=contentsecuritypolicy),
# you can tell the browser that it can only download content from the domains you explicitly allow
# http://www.html5rocks.com/en/tutorials/security/content-security-policy/
# https://www.owasp.org/index.php/Content_Security_Policy
add_header Content-Security-Policy "default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob: mediastream:;" always;

# redirect all http traffic to https
# server {
#   listen 80;
#   listen [::]:80;
#   server_name {{ app_name }}<domain>;
#   return 301 https://$host:443$request_uri;
# }

server {
    listen 80;
    listen [::]:80;
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name {{ app_name }}<domain> {{ inventory_hostname }};

    set_real_ip_from xxx.xxx.xxx.xxx;
    real_ip_header X-Forwarded-For;
    real_ip_recursive on;

    # ssl configuration
    ssl_certificate         /etc/ssl/certs/{{ app_name }}-zert.bundle.pem;
    ssl_certificate_key     /etc/ssl/private/{{ app_name }}-key.key;
    # explicitly enable only certain protocols (no SSLv3)
    ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;
    # enables server-side protection from BEAST attacks
    ssl_prefer_server_ciphers on;
    # allow several ciphers
    ssl_ciphers		EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA512:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:ECDH+AESGCM:ECDH+AES256:DH+AESGCM:DH+AES256:RSA+AESGCM:!aNULL:!eNULL:!LOW:!RC4:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS;
    # ssl_ciphers		ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA;
    ssl_session_cache       shared:SSL:10m;

    # diffi hellman params
    # generate using
    # openssl dhparam 4096 > /etc/ssl/dhparam.pem
    ssl_dhparam             /etc/ssl/dhparam.pem;

    # activate HSTS (force using ssl certificate for this domain)
    add_header              Strict-Transport-Security "max-age=15768000;" always;

    #
    # Note: You should disable gzip for SSL traffic.
    # See: https://bugs.debian.org/773332
    #
    # Read up on ssl_ciphers to ensure a secure configuration.
    # See: https://bugs.debian.org/765782
    #
    # Self signed certs generated by the ssl-cert package
    # Don't use them in a production server!
    #
    # include snippets/snakeoil.conf;

    # deny access to .htaccess files (just in case)
    location ~ /\.ht {
        deny all;
    }

    # deny access to .git files (just in case)
    location ~ /\.git {
        deny all;
    }

    # deny readme files etc...
    location ~ ^/(?:\.htaccess|README){
        deny   all;
    }

    ## Deny illegal Host headers
    if ($host !~* ^({{ app_name }}<domain>|{{ inventory_hostname }})$ ) {
        return 444;
    }

    # allow 20 GB of body to be transferred
    client_max_body_size       20G;

    # frontend app root
    root /var/www/eworkbench/public;

    # alias for static files
    location /static/ {
        autoindex off;
        alias /var/django/eworkbench/htdocs/static/;
    }

    # handle x-accel-redirect (with an alias to /uploaded_media/)
    location /uploads/ {
        internal;
        autoindex off;
        alias /mnt/nas_tuze_bib_workbench/{{ app_name }}/;

        etag off;

        # handle x-accel- headers
        add_header Content-Length $upstream_http_x_accel_content_length;
        add_header Last-Modified $upstream_http_x_accel_last_modified;
        add_header etag $upstream_http_x_accel_etag;
    }

    # handle uploads
    error_page 588 = @saveinfile;

    location = /webdav/auth/ {
        # webdav auth request (internal)
        #internal;

        # cache this internal request for a minute
        proxy_cache auth_cache;

        proxy_cache_key "$http_authorization/$scheme$proxy_host";
        proxy_cache_valid 60m;

        # uncomment the following line for some debug information of the cache key
        add_header X-Cache-Key "$http_authorization/$scheme$proxy_host";

        client_max_body_size       20G;

        # disable body, body is already handled by client_body_temp_path
        proxy_set_body             off;

        include conf.d/{{ app_name }}.proxy;
    }

        location /webdav/ {
                # allow body to be big enough for large files
                client_max_body_size       20G;

                # handle put requests differently...
                if ($request_method = PUT) {
                        return 588;
                }

                include conf.d/{{ app_name }}.proxy;
        }


    location @saveinfile {
        # auth via backend (if the subrequest returns a 2xx response code, the access is allowed. If it returns 401 or 403,
        # the access is denied) before we store the file
        # see http://nginx.org/en/docs/http/ngx_http_auth_request_module.html
        auth_request        /webdav/auth/;

        proxy_read_timeout 600;
        proxy_send_timeout 600;
        proxy_connect_timeout 600;

        # handle uploads using body to file
        client_body_temp_path      /mnt/nas_tuze_bib_workbench/{{ app_name }}_tmp;
        client_body_in_file_only   on;
        client_body_buffer_size    1M;
        # specify a header, telling our application that the file has already been stored
        proxy_set_header           X-File-Name $request_body_file;
        # disable body, body is already handled by client_body_temp_path
        proxy_set_body             off;

        include conf.d/{{ app_name }}.proxy;
    }

    # alias for uploaded files (without x-accel-redirect)
    location /uploaded_media/ {
        autoindex off;
        alias /mnt/nas_tuze_bib_workbench/{{ app_name }}/;
    }

    # alias for plugins
    location /plugins/ {
        autoindex off;
        alias {{ plugins_root_path }}/;
    }

    index index.html;

    location / {
        # raise a 503 (maintenance) error, if maintenance.enable exists
        # if ($remote_addr != 188.65.77.77) {
        if (-f /var/www/eworkbench/public/maintenance.enable) {
            return 503;
        }
        set $is_windows_optionscall "";
        if ($http_user_agent ~* 'Microsoft-WebDAV-MiniRedir|DavClnt' ) {
            set $is_windows_optionscall "1";
        }
        # fix for windows + webdav
        if ($request_method = OPTIONS ) {
            set $is_windows_optionscall "${is_windows_optionscall}1";
        }

        if ($is_windows_optionscall = '11') {
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 200;
        }

        # First attempt to serve request as file, then
        # as directory, then fall back to index.html
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-store, no-cache, must-revalidate";
    }

    # error 503 redirect to maintenance.html
    error_page 503 @maintenance;
    location @maintenance {
        expires -1;
        add_header 'Cache-Control' 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0';
        rewrite ^(.*)$ /maintenance.html break;
    }

    # proxy stuff for django
    location ~^/(admin|api|ws|short_url|caldav|openapi|ckeditor) {
        # timeout for uploads
        # timeout is set only between two successive read operations, not for the transmission of the whole response.
        # If the proxied server does not transmit anything within this time, the connection is closed.
        proxy_read_timeout 600;
        proxy_send_timeout 600;
        # timeout for establishing a connection with a proxied server
        proxy_connect_timeout 15;

        include conf.d/{{ app_name }}.proxy;
    }

    location /api/study-room-booking-export/calendar/ { # restrict access to /api/study-room-booking-export/calendar/
        allow 10.0.0.0/8;  # (Private)
        deny all;
        try_files $uri $uri/ @django;
    }

}
